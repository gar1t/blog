#+HUGO_SECTION: blog
#+HUGO_BASE_DIR: .
#+hugo_auto_set_lastmod: t

* Ocaml                                                               :ocaml:
** Setting up OCaml and Emacs with Nix/NixOS
:PROPERTIES:
:EXPORT_FILE_NAME: ocaml_with_nix
:END:

I'm learning OCaml via [[https://realworldocaml.org/][Real World OCaml]], and getting a isolated OCaml
development environment working with NixOS proved to be quite a
struggle. This is a tutorial that describes /my/ way of getting OCaml
set up.
*** Obtaining the OCaml Libraries
OCaml and the more popular libraries are available in Nixpkgs, so one
can write a simple ~shell.nix~ file to make them available in a nix
shell:

#+BEGIN_SRC nix
  with import <nixpkgs> {};

  let
    ocamlPackages = pkgs.recurseIntoAttrs pkgs.ocamlPackages_latest;
  in
  {
    pkgs.mkShell {
       buildInputs = with pkgs; [
        dune
      ] ++ ( with ocamlPackages;
      [
        ocaml
        core
        core_extended
        findlib
        utop
        merlin
        ocp-indent
      ]);
    }
  }
#+END_SRC

With this, we now have OCaml and the ~Core~ standard library available
in an isolated environment. We also installed [[https://github.com/ocaml/merlin/][Merlin]], which provides
context-sensitive completion, and [[https://github.com/OCamlPro/ocp-indent][ocp-indent]], which provides
auto-formatting of OCaml code.

The issue with many of these OCaml libraries is that they are tied to
their compiler versions. In addition, tools like merlin require the
ability to locate OCaml libraries, which is tricky business in Nix
land.

Merlin and utop distribute their emacs-lisp libraries with the main
executables. This means upon building the Nix derivations, one would
find them in ~${package}/share/emacs/site-lisp~. These libraries would
need to be added to the Emacs load-path and loaded. In ordinary
scenarios, I use [[https://direnv.net/][direnv]], which has first-class support for Nix and
nix-shell environments, to automatically load project-specific
libraries and binaries. This didn't work out. Instead, now I launch a
separate Emacs instance within the nix-shell that would have access to
all the executable and OCaml libraries.

*** Passing information via shell variables
I use shell variables to pass information to my Emacs configuration.
First, I pass a set ~IN_NIX_SHELL~ to ~1~ in the nix-shell environment.
This is simple enough:

#+BEGIN_SRC nix
  pkgs.mkShell {
    IN_NIX_SHELL = 1;
  }
#+END_SRC

In Emacs, I write a function that checks if I'm in a nix-shell using
this variable:

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun in-nix-shell-p ()
    (string-equal (getenv "IN_NIX_SHELL") "1"))
#+END_SRC

Next, I would also need to pass the site-lisp directories for merlin,
utop and ocp-indent to Emacs:

#+BEGIN_SRC nix
  pkgs.mkShell {
    UTOP_SITE_LISP = "${ocamlPackages.utop}/share/emacs/site-lisp";
    MERLIN_SITE_LISP = "${ocamlPackages.merlin}/share/emacs/site-lisp";
    OCP_INDENT_SITE_LISP="${ocamlPackages.ocp-indent}/share/emacs/site-lisp";
  }
#+END_SRC

Here's how a final [[https://github.com/jethrokuan/advent-2018/blob/d792855a5783fdb52753e71cfbcc7921c40f1d07/shell.nix][shell.nix]] would look like.

In Emacs I then conditionally load the libraries depending on:

1. Whether I'm in a nix-shell.
2. Whether these environment variables are passed.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq jethro/merlin-site-elisp (getenv "MERLIN_SITE_LISP"))
  (setq jethro/utop-site-elisp (getenv "UTOP_SITE_LISP"))
  (setq jethro/ocp-site-elisp (getenv "OCP_INDENT_SITE_LISP"))

  (use-package merlin
    :if (and jethro/merlin-site-elisp
             (in-nix-shell-p))
    :load-path jethro/merlin-site-elisp
    :hook
    (tuareg-mode . merlin-mode)
    (merlin-mode . company-mode)
    :custom
    (merlin-command "ocamlmerlin"))

  (use-package utop
    :if (and jethro/utop-site-elisp
             (in-nix-shell-p))
    :load-path jethro/utop-site-elisp
    :hook
    (tuareg-mode . utop-minor-mode))

  (use-package ocp-indent
    :if (and jethro/ocp-site-elisp
             (in-nix-shell-p))
    :load-path jethro/ocp-site-elisp)
#+END_SRC

This part of my Emacs configuration continues to work for my own
user-level Emacs daemon, and now performs additional work loading
elisp provided by merlin, utop and ocp-indent when launched within my
OCaml isolated environment.

Hope this will help others set up their OCaml environment with NixOS!
Many thanks to [[https://gist.github.com/henrytill/7c1831b31d7780e64a2d53120aee13a1][this gist]] for leading me in the right direction.

** TODO Real World OCaml: A Review
:PROPERTIES:
:EXPORT_FILE_NAME: real_world_ocaml_review
:END:

- Real World OCaml is peppered with interesting tidbits about the
  implementations of OCaml that help with understanding the way the
  language is constructed.

Here's a quote about the limitations of pattern matching, which
helped my understand the deliberation behind its constraints.

#+BEGIN_QUOTE
You can think of patterns as a specialized sublanguage that can
express a limited (though still quite rich) set of conditions. The
fact that the pattern language is limited turns out to be a good
thing, making it possible to build better support for patterns in the
compiler. In particular, both the efficiency of match statements and
the ability of the compiler to detect errors in matches depend on the
constrained nature of patterns.
#+END_QUOTE

* Emacs                                                               :emacs:

** TODO Knowledge Management with Org-mode and Deft

** TODO Getting Things Done with Org-mode

* Retrospectives

** 2018 in Review
:PROPERTIES:
:EXPORT_FILE_NAME: 2018_in_review
:END:

At the end of the year, I normally conduct a retrospective. This is,
however, the first time I'm making it public. Naturally, there are
things that I cannot, or am unwilling to share, and hence this
represents a subset of my reflection over 2018. Here I share the key
milestones and some thoughts in chronological order.

January marked the start of my second semester as a Year 2 Computer
Science student in the National University of Singapore. Some time
late last year, I took an interest in Machine Learning, working on
Carousell's image search and price suggestion mechanism. I took many
ML-related modules, and undertook an undergraduate research project
(more on this later). I took a total of 8 modules, spreading myself
way too thin. I struggled quite a bit that semester, but managed to
pull through because the modules I were taking were interesting and
interconnected.

After the semester I took a nice break in eastern Europe, visiting
Croatia, Bosnia and Slovenia. Upon my return, I joined Carousell as a
Data Scientist Intern, where I internationalized the smart chat
replies feature to non-English speaking countries like Hong Kong. I
also worked on the pipeline that powers the new image search and price
suggestion mechanism. I'm grateful to have been given the opportunity
to work on high-impact features, using large datasets consisting of
millions of products to train models. Carousell has a great data
pipeline that abstracts away a lot of the painful data pre-processing
work for me, allowing me to focus on my experiments and getting things
to work. On hindsight, I should've been more proactive in seeking
advice or looking for colleagues to bounce ideas with: that would've
saved me a significant amount of time.

Before school resumed, I took a short trip to Hangzhou for a Data
Visualization Summer School, with a couple of friends. The summer
school was poorly planned and had a lot of repeated content. However,
we visited a NLP engineer at the Alibaba HQ, and had lots of good
food during our stay.

After a tiring first semester, I decided to take fewer modules. These
modules were 4k modules, and proved to be quite challenging. During
this time, I also continued working part-time for Carousell. This was
also the season for internship applications overseas. At the same
time, I had to put in extra work on the undergraduate research project
I had undertaken at the start of the year, because I chose an
open-ended project and went down a research direction where I couldn't
make substantial contributions. Once again, I was spread way too thin,
and had too many commitments. Things didn't go as smoothly in this
semester.

I applied to a dozen companies, and the interviews lasted from October
into late November. I was not sufficiently prepared for the
interviews, and had erratic performance for each interview. This
proved detrimental, because the application process for all companies
span multiple interviews, and a poor performance in one meant
immediate disqualification. Jane Street invited me to Hong Kong for an
onsite, and I lacked the confidence and preparation to produce clean
and correct answers. What I needed to do better was consistent and
intense practice, including both problems on Leetcode and mock
interviews. On hindsight, an overseas internship was not particularly
high on my priority list, and not getting one is fine with me.

*** Things that went well
In 2018, I adopted, or was more consistent with a number of practices
that I have found to be quite helpful.

First on the list is exercise and meditation. Despite my busy
schedules, a morning run always helped start my day right.

Coming in closely in second place would be reading. I've read 43 books
this year, up from 10 last year. The books I read ranged from
textbooks, to both fiction and non-fiction. I read one fiction book
and one non-fiction book at a time. I read at night, and this helps me
end the day away from the computers.

*** Things that went badly
This year I've been extremely sloppy with deadlines and time
management. I started one of my group projects the week it was due, a
project for which we were given more than 6 weeks. The situation has
slightly improved after I became more rigorous in my Getting Things
Done workflow, and I would need to revisit and simplify this workflow.

I've also spent many days in procrastination. A large part of me is
convinced that this is burnout. I've also definitely not slept enough
this year, and now know acutely the effects of lack of sleep. I've
fallen sick more times than I have in the past half a decade. To
resolve both these problems, I need to settle into a good day and
night routine, and the December holidays is perfect for that.

*** Favourites
Here are some of my favourites of 2018.

**** Books Read
[[http://www.inference.org.uk/itprnn/book.html][David MacKay: Information Theory, Pattern Recognition and Neural
Networks]] was introduced to me as the companion textbook for my
Information Theory module for the first semester of the year, and this
quickly became my favourite textbook of all time. Mackay has the
ability to present information about difficult concepts (I'm looking
at you, Monte Carlo sampling) in an entertaining and digestable
manner. This book also draws the link between statistical inference,
neural networks and information theory, all three interesting topics
stand-alone, but delightful together.

As for fiction, [[https://www.goodreads.com/book/show/20518872-the-three-body-problem][The Three-Body Problem]] is both thought-provoking for
its clever use of scientific ideas, as well as being a depiction of
the Chinese culture during the revolution. I also found myself hooked
to the [[https://www.goodreads.com/book/show/15839976-red-rising?ac=1&from_search=true][Red Rising]] tetralogy.

* Software Engineering                                         :software_eng:
** The Unix Philosophy                                                :unix:
:PROPERTIES:
:EXPORT_FILE_NAME: unix_philosophy
:END:

In [[https://www.goodreads.com/book/show/104745.The_Art_of_UNIX_Programming][The Art of Unix Programming]], Ken Thompson was quoted to have
provided the following design rules:

- Build modular programs
- Write readable programs
- Use composition
- Separate mechanisms from policy
- Write simple programs
- Write small programs
- Write transparent programs
- Write robust programs
- Make data complicated when required, not the program
- Build on potential users' expected knowledge
- Avoid unnecessary output
- Write programs which fail in a way easy to diagnose
- Value developer time over machine time
- Write abstract programs that generate code instead of writing code by hand
- Prototype software before polishing it
- Write flexible and open programs
- Make the program and protocols extensible

Particularly fascinating was the point on separating mechanisms from
policy. The argument is that mechanisms don't evolve as quickly as
policies, hence coupling the two would make it difficult to improve
upon the software without breaking the mechanism. Eric gave the
example of X, and the survival of X was attributed to its mechanisms
(the raster operations) being separated from the GUI implementations,
which had been phased out multiple times.

** Litmus Tests for Writing Code                                      :unix:
:PROPERTIES:
:EXPORT_FILE_NAME: code_litmus_tests
:END:

Here are some questions you can ask yourself when evaluating the code
you write:

1. *API Modularity*: Can you describe well your API, if written in a purely human
   language with no code extracts?
2. *Compactness*: Does an experienced user need a manual?
3. Does changing a part of code affect other system properties?
4. *Single Point of Truth*: Do data structures have states with 1-1
   correspondence with the states of the real-world system?
5. *Code Modularity*: Are there any global variables? Is the size of
   modules too large? Are there any large functions? What is the call
   maximum stack depth (excluding recursion)? Are there many internal
   APIs? What is the number of entry points to the module?
6. *Transparency*: Are there any special cases? Are there any magic
   numbers? Are each function calls orthogonal? Are there many mode
   flags? Is the high-level state of the system easily inspectable?
   Can you see what the system is doing through any debug output?

Others:

1. Are you using a binary format? Have you considered the pros and
   cons of that, against a simple textual format?
